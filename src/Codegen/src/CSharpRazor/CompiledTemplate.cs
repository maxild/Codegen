using System;
using System.Reflection;
using System.Threading.Tasks;

namespace CSharpRazor
{
    /// <summary>
    /// This is a wrapper/descriptor that captures the dynamically compiled
    /// <see cref="Assembly"/> that hosts the <see cref="TemplateBase"/>
    /// derived type.
    /// </summary>
    public class CompiledTemplate : ICompiledTemplateDescriptor
    {
        private readonly Assembly _compiledAssembly;

        internal CompiledTemplate(CompiledTemplateILSource source)
        {
            if (source is null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            TemplateName = source.TemplateName;
            TemplateFilename = source.TemplateFilename;
            TypeName = source.TypeName;
            SourceCSharpCode = source.SourceCSharpCode;
            // As part of the .NET Standard 2.0 effort, certain assembly load APIs off the Assembly type,
            // which were present in Desktop .NET Framework, have been brought back.
            // The Assembly.Load(byte[], [ byte[] ]) API will delegate to the IndividualAssemblyLoadContext
            // in .NET Core. This creates a new (anonymous) load context to load the assembly into.
            _compiledAssembly = Assembly.Load(source.RawAssembly, source.RawAssemblySymbols);
        }

        /// <inheritdoc />
        public string TemplateName { get; }

        /// <inheritdoc />
        public string TemplateFilename { get; }

        /// <inheritdoc />
        public string TypeName { get; }

        /// <inheritdoc />
        public string SourceCSharpCode { get; }

        /// <summary>
        /// Render the compiled template after binding a given model instance.
        /// </summary>
        /// <param name="model">The template model instance.</param>
        /// <returns>The resulting text generated by rendering the compiled template with the bound model instance.</returns>
        public async Task<string> RenderAsync(object model)
        {
            return await New().RenderAsync(model);
        }

        /// <summary>
        /// Create a new instance of the the <see cref="TemplateBase"/>
        /// derived type -- this corresponds to calling the default constructor,
        /// but we cannot do such a thing on a dynamically compiled, emitted, loaded
        /// type.
        /// </summary>
        /// <returns>A new instance of the <see cref="TemplateBase"/> derived type.</returns>
        private TemplateBase New()
        {
            var rawInstance = _compiledAssembly.CreateInstance(TypeName);
            if (rawInstance is null)
            {
                throw new InvalidOperationException($"UNEXPECTED: Could not create instance of {TypeName}.");
            }

            // We only need the base type without strongly typed TModel generic arg
            if (!(rawInstance is TemplateBase templateInstance))
            {
                throw new InvalidOperationException(
                    $"UNEXPECTED: Could not cast to {typeof(TemplateBase).FullName}. The actual page base type is {rawInstance.GetType().BaseType?.FullName}.");
            }

            return templateInstance;
        }
    }
}
